<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>8.5.&nbsp;RegionServer</title><link rel="stylesheet" type="text/css" href="../css/freebsd_docbook.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><link rel="home" href="book.html" title=""><link rel="up" href="architecture.html" title="Chapter&nbsp;8.&nbsp;Architecture"><link rel="prev" href="master.html" title="8.4.&nbsp;Master"><link rel="next" href="regions.arch.html" title="8.6.&nbsp;Regions"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">8.5.&nbsp;RegionServer</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="master.html">Prev</a>&nbsp;</td><th width="60%" align="center">Chapter&nbsp;8.&nbsp;Architecture</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="regions.arch.html">Next</a></td></tr></table><hr></div><div class="section" title="8.5.&nbsp;RegionServer"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="regionserver.arch"></a>8.5.&nbsp;RegionServer</h2></div></div></div><p><code class="code">HRegionServer</code> is the RegionServer implementation.  It is responsible for serving and managing regions.
       In a distributed cluster, a RegionServer runs on a <a class="xref" href="arch.hdfs.html#arch.hdfs.dn" title="8.7.2.&nbsp;DataNode">Section&nbsp;8.7.2, &#8220;DataNode&#8221;</a>.  
       </p><div class="section" title="8.5.1.&nbsp;Interface"><div class="titlepage"><div><div><h3 class="title"><a name="regionserver.arch.api"></a>8.5.1.&nbsp;Interface</h3></div></div></div><p>The methods exposed by <code class="code">HRegionRegionInterface</code> contain both data-oriented and region-maintenance methods:
         </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Data (get, put, delete, next, etc.)
            </li><li class="listitem">Region (splitRegion, compactRegion, etc.)  
            </li></ul></div><p>
         For example, when the <code class="code">HBaseAdmin</code> method <code class="code">majorCompact</code> is invoked on a table, the client is actually iterating through
         all regions for the specified table and requesting a major compaction directly to each region. 
         </p></div><div class="section" title="8.5.2.&nbsp;Processes"><div class="titlepage"><div><div><h3 class="title"><a name="regionserver.arch.processes"></a>8.5.2.&nbsp;Processes</h3></div></div></div><p>The RegionServer runs a variety of background threads:</p><div class="section" title="8.5.2.1.&nbsp;CompactSplitThread"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.compactsplit"></a>8.5.2.1.&nbsp;CompactSplitThread</h4></div></div></div><p>Checks for splits and handle minor compactions.</p></div><div class="section" title="8.5.2.2.&nbsp;MajorCompactionChecker"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.majorcompact"></a>8.5.2.2.&nbsp;MajorCompactionChecker</h4></div></div></div><p>Checks for major compactions.</p></div><div class="section" title="8.5.2.3.&nbsp;MemStoreFlusher"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.memstore"></a>8.5.2.3.&nbsp;MemStoreFlusher</h4></div></div></div><p>Periodically flushes in-memory writes in the MemStore to StoreFiles.</p></div><div class="section" title="8.5.2.4.&nbsp;LogRoller"><div class="titlepage"><div><div><h4 class="title"><a name="regionserver.arch.processes.log"></a>8.5.2.4.&nbsp;LogRoller</h4></div></div></div><p>Periodically checks the RegionServer's HLog.</p></div></div><div class="section" title="8.5.3.&nbsp;Block Cache"><div class="titlepage"><div><div><h3 class="title"><a name="block.cache"></a>8.5.3.&nbsp;Block Cache</h3></div></div></div><p>The Block Cache contains three levels of block priority to allow for scan-resistance and in-memory ColumnFamilies.  A block is added with an in-memory
       flag if the containing ColumnFamily is defined in-memory, otherwise a block becomes a single access priority.  Once a block is accessed again, it changes to multiple access. 
       This is used to prevent scans from thrashing the cache, adding a least-frequently-used element to the eviction algorithm.  Blocks from in-memory ColumnFamilies
       are the last to be evicted.
       </p><p>
        For more information, see the <a class="link" href="http://hbase.apache.org/xref/org/apache/hadoop/hbase/io/hfile/LruBlockCache.html" target="_top">LruBlockCache source</a>
        </p></div><div class="section" title="8.5.4.&nbsp;Write Ahead Log (WAL)"><div class="titlepage"><div><div><h3 class="title"><a name="wal"></a>8.5.4.&nbsp;Write Ahead Log (WAL)</h3></div></div></div><div class="section" title="8.5.4.1.&nbsp;Purpose"><div class="titlepage"><div><div><h4 class="title"><a name="purpose.wal"></a>8.5.4.1.&nbsp;Purpose</h4></div></div></div><p>Each RegionServer adds updates (Puts, Deletes) to its write-ahead log (WAL)
            first, and then to the <a class="xref" href="regions.arch.html#store.memstore" title="8.6.4.1.&nbsp;MemStore">Section&nbsp;8.6.4.1, &#8220;MemStore&#8221;</a> for the affected <a class="xref" href="regions.arch.html#store" title="8.6.4.&nbsp;Store">Section&nbsp;8.6.4, &#8220;Store&#8221;</a>.  
        This ensures that HBase has durable writes. Without WAL, there is the possibility of data loss in the case of a RegionServer failure 
        before each MemStore is flushed and new StoreFiles are written.  <a class="link" href="http://hbase.apache.org/apidocs/org/apache/hadoop/hbase/regionserver/wal/HLog.html" target="_top">HLog</a> 
        is the HBase WAL implementation, and there is one HLog instance per RegionServer.
       </p>The WAL is in HDFS in <code class="filename">/hbase/.logs/</code> with subdirectories per region.
       <p>
        For more general information about the concept of write ahead logs, see the Wikipedia
        <a class="link" href="http://en.wikipedia.org/wiki/Write-ahead_logging" target="_top">Write-Ahead Log</a> article.
       </p></div><div class="section" title="8.5.4.2.&nbsp;WAL Flushing"><div class="titlepage"><div><div><h4 class="title"><a name="wal_flush"></a>8.5.4.2.&nbsp;WAL Flushing</h4></div></div></div><p>TODO (describe).
          </p></div><div class="section" title="8.5.4.3.&nbsp;WAL Splitting"><div class="titlepage"><div><div><h4 class="title"><a name="wal_splitting"></a>8.5.4.3.&nbsp;WAL Splitting</h4></div></div></div><div class="section" title="8.5.4.3.1.&nbsp;How edits are recovered from a crashed RegionServer"><div class="titlepage"><div><div><h5 class="title"><a name="d1223e4097"></a>8.5.4.3.1.&nbsp;How edits are recovered from a crashed RegionServer</h5></div></div></div><p>When a RegionServer crashes, it will lose its ephemeral lease in
         ZooKeeper...TODO</p></div><div class="section" title="8.5.4.3.2.&nbsp;hbase.hlog.split.skip.errors"><div class="titlepage"><div><div><h5 class="title"><a name="d1223e4102"></a>8.5.4.3.2.&nbsp;<code class="varname">hbase.hlog.split.skip.errors</code></h5></div></div></div><p>When set to <code class="constant">true</code>, the default, any error
        encountered splitting will be logged, the problematic WAL will be
        moved into the <code class="filename">.corrupt</code> directory under the hbase
        <code class="varname">rootdir</code>, and processing will continue. If set to
        <code class="constant">false</code>, the exception will be propagated and the
        split logged as failed.<sup>[<a name="d1223e4120" href="#ftn.d1223e4120" class="footnote">20</a>]</sup></p></div><div class="section" title="8.5.4.3.3.&nbsp;How EOFExceptions are treated when splitting a crashed RegionServers' WALs"><div class="titlepage"><div><div><h5 class="title"><a name="d1223e4126"></a>8.5.4.3.3.&nbsp;How EOFExceptions are treated when splitting a crashed
        RegionServers' WALs</h5></div></div></div><p>If we get an EOF while splitting logs, we proceed with the split
        even when <code class="varname">hbase.hlog.split.skip.errors</code> ==
        <code class="constant">false</code>. An EOF while reading the last log in the
        set of files to split is near-guaranteed since the RegionServer likely
        crashed mid-write of a record. But we'll continue even if we got an
        EOF reading other than the last file in the set.<sup>[<a name="d1223e4137" href="#ftn.d1223e4137" class="footnote">21</a>]</sup></p></div></div></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a id="ftn.d1223e4120" href="#d1223e4120" class="para">20</a>] </sup>See <a class="link" href="https://issues.apache.org/jira/browse/HBASE-2958" target="_top">HBASE-2958
            When hbase.hlog.split.skip.errors is set to false, we fail the
            split but thats it</a>. We need to do more than just fail split
            if this flag is set.</p></div><div class="footnote"><p><sup>[<a id="ftn.d1223e4137" href="#d1223e4137" class="para">21</a>] </sup>For background, see <a class="link" href="https://issues.apache.org/jira/browse/HBASE-2643" target="_top">HBASE-2643
            Figure how to deal with eof splitting logs</a></p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="master.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="architecture.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="regions.arch.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">8.4.&nbsp;Master&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="book.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;8.6.&nbsp;Regions</td></tr></table></div></body></html>